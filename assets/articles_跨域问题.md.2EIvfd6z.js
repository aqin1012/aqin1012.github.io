import{_ as s,o as i,c as a,R as e}from"./chunks/framework.vB1haF5z.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/跨域问题.md","filePath":"articles/跨域问题.md"}'),t={name:"articles/跨域问题.md"},l=e(`<p>很多时候，你会遇到莫名的跨域问题，有时候后台报错也会显示前台跨域，导致也不知道是不是真的跨域。</p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><ol><li>安装 双核浏览器 最新的chrome已经不支持跨域设置</li><li>chrome://flags/#same-site-by-default-cookies 设置 Disabled</li><li>chrome://flags/#enable-removing-all-third-party-cookies 设置 Disabled</li><li>如果你是多站点，使用Nginx，使其变成一个域,我的配置文件还有代理中转后台。 Nginx 配置文件代码</li><li>后台请求头设置跨域代码，这样前后台就打通不跨域了。后台处理好option请求，不要报错。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Access-Control-Allow-Origin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;源地址&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Access-Control-Allow-Credentials&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>这里 源地址 不能是*，可以设置成 谁请求你，你就设置成他的地址</p><ol><li>如果后台需要session，前台请求的axios设置 withCredentials: true,发送请求自动携带cookie。 java 携带session 前台传递cookie 跨域解决方案 vue + java 如果这个时候还发生跨域 当你发现，某个接口，或某几个接口跨域，其他接口不跨域，基本上就是后台代码发生错误导致。</li></ol>`,6),n=[l];function o(h,r,p,k,c,d){return i(),a("div",null,n)}const g=s(t,[["render",o]]);export{E as __pageData,g as default};
